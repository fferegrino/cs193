// This file has been autogenerated from a class added in the UI designer.

using System;
using System.Linq;

using Foundation;
using UIKit;
using CoreGraphics;
using System.Collections.Generic;
using CoreMotion;

namespace DropIt
{
	public partial class DropItView : NamedBezierPathsView, IUIDynamicAnimatorDelegate
	{
		Random r = new Random();

		public DropItView(IntPtr handle) : base(handle)
		{
		}

		UIDynamicAnimator _animator;
		UIDynamicAnimator animator => _animator ?? (_animator = new UIDynamicAnimator(this) { Delegate = this });

		public void WillResume(UIDynamicAnimator animator)
		{
			//throw new NotImplementedException();
		}

		public void DidPause(UIDynamicAnimator animator)
		{
			RemoveCompletedRow();
		}

		FallingObjectBehavior dropBehavior = new FallingObjectBehavior();

		private bool _animating;
		public bool Animating
		{
			get { return _animating; }
			set
			{
				_animating = value;
				if (_animating)
				{
					animator.AddBehavior(dropBehavior);
				}
				else
				{
					animator.RemoveBehavior(dropBehavior);
				}
			}
		}

		private bool _realGravity;
		public bool RealGravity
		{
			get { return _realGravity; }
			set { _realGravity = value;
				UpdateRealGravity();
			}
		}

		CMMotionManager motionManager = new CMMotionManager();
		void UpdateRealGravity()
		{
			if (_realGravity)
			{
				if (motionManager.AccelerometerAvailable && !motionManager.AccelerometerActive)
				{
					motionManager.AccelerometerUpdateInterval = 0.25;
					motionManager.StartAccelerometerUpdates(NSOperationQueue.MainQueue, (data, error) => 
					{
						if (dropBehavior.DynamicAnimator != null)
						{
							var dx = data?.Acceleration.X;
							var dy = data?.Acceleration.Y;
							if (dx != null && dy != null)
							{
								switch (UIDevice.CurrentDevice.Orientation)
								{
									case UIDeviceOrientation.Portrait: dy = -dy; break;
									case UIDeviceOrientation.PortraitUpsideDown: break;
									case UIDeviceOrientation.LandscapeLeft: // Swap break;
									case UIDeviceOrientation.LandscapeRight: // Swap - dy = -dy; break;
									default:
										break;
								}
								dropBehavior.gravity.GravityDirection = new CGVector((System.nfloat)dx, (System.nfloat)dy);
							}
						}
					});
				}
			}
			else 
			{
				motionManager.StopAccelerometerUpdates();
			}
		}

		UIAttachmentBehavior _attachment;
		UIAttachmentBehavior Attachment
		{
			get { return _attachment; }
			set
			{
				if (_attachment != null)
				{
					animator.RemoveBehavior(_attachment);
					this.RemoveBezierPath(PathNames.Attachment);
				}
				_attachment = value;

				if (_attachment != null)
				{ 
					animator.AddBehavior(_attachment);
					Attachment.Action = () =>
					{
						var attachedDrop = Attachment?.Items.First() as UIView;
						if (attachedDrop != null)
						{
							var linePath = new UIBezierPath();
							var middleDrop = attachedDrop.Center;
							linePath.MoveTo(Attachment.AnchorPoint);
							System.Diagnostics.Debug.WriteLine($"Anchor {Attachment.AnchorPoint} | Mid {middleDrop}");

							linePath.AddLineTo(middleDrop);
							this.AddBeizerPath(PathNames.Attachment, linePath);
						}
						else
						{ 
							System.Diagnostics.Debug.WriteLine($"Attached drop is null");
						}
					};
				}
			}
		}

		private struct PathNames
		{
			public const string MiddleBarrier = "Middle Barrier";
			public const string Attachment = "Attachment";
		}

		public override void LayoutSubviews()
		{
			base.LayoutSubviews();
			var path = UIBezierPath.FromOval(new CGRect(new CGPoint(Bounds.GetMidX(), Bounds.GetMidY()), DropSize));
			dropBehavior.AddBarrier(path, PathNames.MiddleBarrier);
			this.AddBeizerPath(PathNames.MiddleBarrier, path);
		}

		CGPoint AnchorPoint;

		internal void GrabDrop(UIPanGestureRecognizer recognizer)
		{
			var gesturePoint = recognizer.LocationInView(this);
			switch (recognizer.State)
			{
				case UIGestureRecognizerState.Began:
					if (_lastDrop != null && _lastDrop.Superview != null)
					{
						Attachment = new UIAttachmentBehavior(_lastDrop, gesturePoint);
					}
					//_lastDrop = null;
					break;
				case UIGestureRecognizerState.Changed:
					if (Attachment != null)
					{
						Attachment.AnchorPoint = gesturePoint;
					}
					break;
				default:
					Attachment = null;
					break;
			}
		}

		void RemoveCompletedRow()
		{
			List<UIView> dropsToRemove = new List<UIView>();

			var hitTestRect = new CGRect(new CGPoint(Bounds.GetMinX(), Bounds.GetMaxY()), DropSize);
			do
			{
				hitTestRect.X = Bounds.GetMinX();
				hitTestRect.Y -= DropSize.Height;
				var dropsTested = 0;
				List<UIView> dropsFound = new List<UIView>();
				while (dropsTested < DropsPerRow)
				{
					var hitView = HitTest(new CGPoint(hitTestRect.GetMidX(), hitTestRect.GetMidY()), null);
					if (hitView.Superview == this)
					{
						dropsFound.Add(hitView);
					}
					else {
						break;
					}
					hitTestRect.X += DropSize.Width;
					dropsTested += 1;
				}
				if (dropsTested == DropsPerRow)
				{
					dropsToRemove.AddRange(dropsFound);
				}

			} while (dropsToRemove.Count == 0 && hitTestRect.Y < Bounds.GetMinY());
			foreach (var drop in dropsToRemove)
			{
				dropBehavior.RemoveItem(drop);
				drop.RemoveFromSuperview();
			}
		}

		const int DropsPerRow = 10;
		CGSize DropSize => new CGSize(Bounds.Width / DropsPerRow, Bounds.Width / DropsPerRow);

		UIView _lastDrop;

		UIColor[] colors = new UIColor[] { UIColor.Blue,
			UIColor.Yellow, UIColor.Green,
			UIColor.Red, UIColor.Purple, UIColor.Orange,
			UIColor.Cyan, UIColor.Brown, UIColor.Magenta};

		public void AddDrop()
		{
			var frame = new CGRect(CGPoint.Empty, DropSize);
			frame.X = (System.Int32)(r.NextDouble() * DropsPerRow) * DropSize.Width;

			var drop = new UIView(frame);
			drop.BackgroundColor = colors[r.Next() % colors.Length];

			AddSubview(drop);

			dropBehavior.AddItem(drop);
			_lastDrop = drop;

		}

	}
}
